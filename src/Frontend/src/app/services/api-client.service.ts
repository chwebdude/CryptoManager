/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.1.0 (NJsonSchema v10.3.3.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class CryptoApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    apiExchangesAvailableexchanges(): Observable<ExchangeMeta[]> {
        let url_ = this.baseUrl + "/api/Exchanges/availableExchanges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiExchangesAvailableexchanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiExchangesAvailableexchanges(<any>response_);
                } catch (e) {
                    return <Observable<ExchangeMeta[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExchangeMeta[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiExchangesAvailableexchanges(response: HttpResponseBase): Observable<ExchangeMeta[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExchangeMeta.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangeMeta[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiExchangesGet(): Observable<ExchangeDTO[]> {
        let url_ = this.baseUrl + "/api/Exchanges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiExchangesGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiExchangesGet(<any>response_);
                } catch (e) {
                    return <Observable<ExchangeDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExchangeDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiExchangesGet(response: HttpResponseBase): Observable<ExchangeDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExchangeDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangeDTO[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    apiExchangesPost(body: ExchangeSecretsDTO | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Exchanges";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiExchangesPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiExchangesPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApiExchangesPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiExchangesDelete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Exchanges?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiExchangesDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiExchangesDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApiExchangesDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    apiExchangesUpdate(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Exchanges/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiExchangesUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiExchangesUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApiExchangesUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    apiFiatbalances(): Observable<FiatDTO[]> {
        let url_ = this.baseUrl + "/api/FiatBalances";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiFiatbalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiFiatbalances(<any>response_);
                } catch (e) {
                    return <Observable<FiatDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FiatDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiFiatbalances(response: HttpResponseBase): Observable<FiatDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FiatDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FiatDTO[]>(<any>null);
    }

    /**
     * @param exchangeId (optional) 
     * @return Success
     */
    apiFlowsNodes(exchangeId: string | undefined): Observable<FlowNodeDTO[]> {
        let url_ = this.baseUrl + "/api/Flows/Nodes?";
        if (exchangeId === null)
            throw new Error("The parameter 'exchangeId' cannot be null.");
        else if (exchangeId !== undefined)
            url_ += "exchangeId=" + encodeURIComponent("" + exchangeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiFlowsNodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiFlowsNodes(<any>response_);
                } catch (e) {
                    return <Observable<FlowNodeDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlowNodeDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiFlowsNodes(response: HttpResponseBase): Observable<FlowNodeDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FlowNodeDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlowNodeDTO[]>(<any>null);
    }

    /**
     * @param exchangeId (optional) 
     * @return Success
     */
    apiFlowsLinks(exchangeId: string | undefined): Observable<FlowLink[]> {
        let url_ = this.baseUrl + "/api/Flows/Links?";
        if (exchangeId === null)
            throw new Error("The parameter 'exchangeId' cannot be null.");
        else if (exchangeId !== undefined)
            url_ += "exchangeId=" + encodeURIComponent("" + exchangeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiFlowsLinks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiFlowsLinks(<any>response_);
                } catch (e) {
                    return <Observable<FlowLink[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlowLink[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiFlowsLinks(response: HttpResponseBase): Observable<FlowLink[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FlowLink.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlowLink[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiFunds(): Observable<FundDTO[]> {
        let url_ = this.baseUrl + "/api/Funds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiFunds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiFunds(<any>response_);
                } catch (e) {
                    return <Observable<FundDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FundDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiFunds(response: HttpResponseBase): Observable<FundDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FundDTO.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FundDTO[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiInvestments(): Observable<AggrInvestmentDTO> {
        let url_ = this.baseUrl + "/api/Investments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiInvestments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiInvestments(<any>response_);
                } catch (e) {
                    return <Observable<AggrInvestmentDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<AggrInvestmentDTO>><any>_observableThrow(response_);
        }));
    }

    protected processApiInvestments(response: HttpResponseBase): Observable<AggrInvestmentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AggrInvestmentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AggrInvestmentDTO>(<any>null);
    }

    /**
     * @return Success
     */
    apiTransactions(): Observable<CryptoTransaction[]> {
        let url_ = this.baseUrl + "/api/Transactions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTransactions(<any>response_);
                } catch (e) {
                    return <Observable<CryptoTransaction[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CryptoTransaction[]>><any>_observableThrow(response_);
        }));
    }

    protected processApiTransactions(response: HttpResponseBase): Observable<CryptoTransaction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CryptoTransaction.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CryptoTransaction[]>(<any>null);
    }

    /**
     * @return Success
     */
    apiTransactionsRecalculate(): Observable<void> {
        let url_ = this.baseUrl + "/api/Transactions/Recalculate";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTransactionsRecalculate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTransactionsRecalculate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApiTransactionsRecalculate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    weatherforecast(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeatherforecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeatherforecast(<any>response_);
                } catch (e) {
                    return <Observable<WeatherForecast[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeatherForecast[]>><any>_observableThrow(response_);
        }));
    }

    protected processWeatherforecast(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeatherForecast[]>(<any>null);
    }
}

export enum Exchange {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class ExchangeMeta implements IExchangeMeta {
    exchangeId?: Exchange;
    name?: string | undefined;
    readonly supportsPublicKey?: boolean;
    labelPublicKey?: string | undefined;
    readonly supportsPrivateKey?: boolean;
    labelPrivateKey?: string | undefined;
    readonly supportsPassphrase?: boolean;
    labelPassphrase?: string | undefined;

    constructor(data?: IExchangeMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exchangeId = _data["exchangeId"];
            this.name = _data["name"];
            (<any>this).supportsPublicKey = _data["supportsPublicKey"];
            this.labelPublicKey = _data["labelPublicKey"];
            (<any>this).supportsPrivateKey = _data["supportsPrivateKey"];
            this.labelPrivateKey = _data["labelPrivateKey"];
            (<any>this).supportsPassphrase = _data["supportsPassphrase"];
            this.labelPassphrase = _data["labelPassphrase"];
        }
    }

    static fromJS(data: any): ExchangeMeta {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exchangeId"] = this.exchangeId;
        data["name"] = this.name;
        data["supportsPublicKey"] = this.supportsPublicKey;
        data["labelPublicKey"] = this.labelPublicKey;
        data["supportsPrivateKey"] = this.supportsPrivateKey;
        data["labelPrivateKey"] = this.labelPrivateKey;
        data["supportsPassphrase"] = this.supportsPassphrase;
        data["labelPassphrase"] = this.labelPassphrase;
        return data; 
    }
}

export interface IExchangeMeta {
    exchangeId?: Exchange;
    name?: string | undefined;
    supportsPublicKey?: boolean;
    labelPublicKey?: string | undefined;
    supportsPrivateKey?: boolean;
    labelPrivateKey?: string | undefined;
    supportsPassphrase?: boolean;
    labelPassphrase?: string | undefined;
}

export class ExchangeDTO implements IExchangeDTO {
    id?: string;
    comment?: string | undefined;
    exchangeName?: string | undefined;
    exchange?: Exchange;

    constructor(data?: IExchangeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.comment = _data["comment"];
            this.exchangeName = _data["exchangeName"];
            this.exchange = _data["exchange"];
        }
    }

    static fromJS(data: any): ExchangeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["comment"] = this.comment;
        data["exchangeName"] = this.exchangeName;
        data["exchange"] = this.exchange;
        return data; 
    }
}

export interface IExchangeDTO {
    id?: string;
    comment?: string | undefined;
    exchangeName?: string | undefined;
    exchange?: Exchange;
}

export class ExchangeSecretsDTO implements IExchangeSecretsDTO {
    comment?: string | undefined;
    publicKey?: string | undefined;
    privateKey?: string | undefined;
    passphrase?: string | undefined;
    exchangeId?: Exchange;

    constructor(data?: IExchangeSecretsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"];
            this.publicKey = _data["publicKey"];
            this.privateKey = _data["privateKey"];
            this.passphrase = _data["passphrase"];
            this.exchangeId = _data["exchangeId"];
        }
    }

    static fromJS(data: any): ExchangeSecretsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeSecretsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["publicKey"] = this.publicKey;
        data["privateKey"] = this.privateKey;
        data["passphrase"] = this.passphrase;
        data["exchangeId"] = this.exchangeId;
        return data; 
    }
}

export interface IExchangeSecretsDTO {
    comment?: string | undefined;
    publicKey?: string | undefined;
    privateKey?: string | undefined;
    passphrase?: string | undefined;
    exchangeId?: Exchange;
}

export class FiatDTO implements IFiatDTO {
    id?: string;
    currency?: string | undefined;
    invested?: number;
    payout?: number;
    exchangeName?: string | undefined;
    exchangeId?: string;

    constructor(data?: IFiatDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currency = _data["currency"];
            this.invested = _data["invested"];
            this.payout = _data["payout"];
            this.exchangeName = _data["exchangeName"];
            this.exchangeId = _data["exchangeId"];
        }
    }

    static fromJS(data: any): FiatDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FiatDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currency"] = this.currency;
        data["invested"] = this.invested;
        data["payout"] = this.payout;
        data["exchangeName"] = this.exchangeName;
        data["exchangeId"] = this.exchangeId;
        return data; 
    }
}

export interface IFiatDTO {
    id?: string;
    currency?: string | undefined;
    invested?: number;
    payout?: number;
    exchangeName?: string | undefined;
    exchangeId?: string;
}

export class FlowNodeDTO implements IFlowNodeDTO {
    id?: string | undefined;
    dateTime?: Date;
    amount?: number;
    currency?: string | undefined;
    exchangeId?: string;
    comment?: string | undefined;
    transactionId?: string;

    constructor(data?: IFlowNodeDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.currency = _data["currency"];
            this.exchangeId = _data["exchangeId"];
            this.comment = _data["comment"];
            this.transactionId = _data["transactionId"];
        }
    }

    static fromJS(data: any): FlowNodeDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FlowNodeDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        data["exchangeId"] = this.exchangeId;
        data["comment"] = this.comment;
        data["transactionId"] = this.transactionId;
        return data; 
    }
}

export interface IFlowNodeDTO {
    id?: string | undefined;
    dateTime?: Date;
    amount?: number;
    currency?: string | undefined;
    exchangeId?: string;
    comment?: string | undefined;
    transactionId?: string;
}

export class FlowLink implements IFlowLink {
    id?: string;
    dateTime?: Date;
    amount?: number;
    currency?: string | undefined;
    flowNodeSource?: string;
    flowNodeTarget?: string;
    comment?: string | undefined;
    exchangeId?: string;

    constructor(data?: IFlowLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.currency = _data["currency"];
            this.flowNodeSource = _data["flowNodeSource"];
            this.flowNodeTarget = _data["flowNodeTarget"];
            this.comment = _data["comment"];
            this.exchangeId = _data["exchangeId"];
        }
    }

    static fromJS(data: any): FlowLink {
        data = typeof data === 'object' ? data : {};
        let result = new FlowLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        data["flowNodeSource"] = this.flowNodeSource;
        data["flowNodeTarget"] = this.flowNodeTarget;
        data["comment"] = this.comment;
        data["exchangeId"] = this.exchangeId;
        return data; 
    }
}

export interface IFlowLink {
    id?: string;
    dateTime?: Date;
    amount?: number;
    currency?: string | undefined;
    flowNodeSource?: string;
    flowNodeTarget?: string;
    comment?: string | undefined;
    exchangeId?: string;
}

export class CoinMeta implements ICoinMeta {
    symbol?: string | undefined;
    name?: string | undefined;
    imageUrl?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICoinMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbol = _data["symbol"];
            this.name = _data["name"];
            this.imageUrl = _data["imageUrl"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): CoinMeta {
        data = typeof data === 'object' ? data : {};
        let result = new CoinMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["symbol"] = this.symbol;
        data["name"] = this.name;
        data["imageUrl"] = this.imageUrl;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICoinMeta {
    symbol?: string | undefined;
    name?: string | undefined;
    imageUrl?: string | undefined;
    url?: string | undefined;
}

export class FundDTO implements IFundDTO {
    id?: string;
    currency?: string | undefined;
    amount?: number;
    exchangeName?: string | undefined;
    exchangeId?: string;
    worthFiat?: number;
    currentFiatRate?: number;
    coinMeta?: CoinMeta;

    constructor(data?: IFundDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currency = _data["currency"];
            this.amount = _data["amount"];
            this.exchangeName = _data["exchangeName"];
            this.exchangeId = _data["exchangeId"];
            this.worthFiat = _data["worthFiat"];
            this.currentFiatRate = _data["currentFiatRate"];
            this.coinMeta = _data["coinMeta"] ? CoinMeta.fromJS(_data["coinMeta"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FundDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FundDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        data["exchangeName"] = this.exchangeName;
        data["exchangeId"] = this.exchangeId;
        data["worthFiat"] = this.worthFiat;
        data["currentFiatRate"] = this.currentFiatRate;
        data["coinMeta"] = this.coinMeta ? this.coinMeta.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFundDTO {
    id?: string;
    currency?: string | undefined;
    amount?: number;
    exchangeName?: string | undefined;
    exchangeId?: string;
    worthFiat?: number;
    currentFiatRate?: number;
    coinMeta?: CoinMeta;
}

export class InvestmentDTO implements IInvestmentDTO {
    readonly id?: string;
    readonly dateTime?: Date;
    readonly feeAmount?: number;
    readonly feeCurrency?: string | undefined;
    readonly buyAmount?: number;
    readonly buyCurrency?: string | undefined;
    buyFiatRate?: number;
    buyFiatAmount?: number;
    readonly sellAmount?: number;
    readonly sellCurrency?: string | undefined;
    readonly rate?: number;
    currentFiatValue?: number;
    currentFiatRate?: number;
    readonly exchangeId?: string;
    exchangeName?: string | undefined;

    constructor(data?: IInvestmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            (<any>this).feeAmount = _data["feeAmount"];
            (<any>this).feeCurrency = _data["feeCurrency"];
            (<any>this).buyAmount = _data["buyAmount"];
            (<any>this).buyCurrency = _data["buyCurrency"];
            this.buyFiatRate = _data["buyFiatRate"];
            this.buyFiatAmount = _data["buyFiatAmount"];
            (<any>this).sellAmount = _data["sellAmount"];
            (<any>this).sellCurrency = _data["sellCurrency"];
            (<any>this).rate = _data["rate"];
            this.currentFiatValue = _data["currentFiatValue"];
            this.currentFiatRate = _data["currentFiatRate"];
            (<any>this).exchangeId = _data["exchangeId"];
            this.exchangeName = _data["exchangeName"];
        }
    }

    static fromJS(data: any): InvestmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new InvestmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["feeAmount"] = this.feeAmount;
        data["feeCurrency"] = this.feeCurrency;
        data["buyAmount"] = this.buyAmount;
        data["buyCurrency"] = this.buyCurrency;
        data["buyFiatRate"] = this.buyFiatRate;
        data["buyFiatAmount"] = this.buyFiatAmount;
        data["sellAmount"] = this.sellAmount;
        data["sellCurrency"] = this.sellCurrency;
        data["rate"] = this.rate;
        data["currentFiatValue"] = this.currentFiatValue;
        data["currentFiatRate"] = this.currentFiatRate;
        data["exchangeId"] = this.exchangeId;
        data["exchangeName"] = this.exchangeName;
        return data; 
    }
}

export interface IInvestmentDTO {
    id?: string;
    dateTime?: Date;
    feeAmount?: number;
    feeCurrency?: string | undefined;
    buyAmount?: number;
    buyCurrency?: string | undefined;
    buyFiatRate?: number;
    buyFiatAmount?: number;
    sellAmount?: number;
    sellCurrency?: string | undefined;
    rate?: number;
    currentFiatValue?: number;
    currentFiatRate?: number;
    exchangeId?: string;
    exchangeName?: string | undefined;
}

export class AggrInvestmentDTO implements IAggrInvestmentDTO {
    investments?: InvestmentDTO[] | undefined;
    tokenProfits?: { [key: string]: number; } | undefined;
    totalWorth?: number;
    totalTradeInvest?: number;
    profit?: number;

    constructor(data?: IAggrInvestmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["investments"])) {
                this.investments = [] as any;
                for (let item of _data["investments"])
                    this.investments!.push(InvestmentDTO.fromJS(item));
            }
            if (_data["tokenProfits"]) {
                this.tokenProfits = {} as any;
                for (let key in _data["tokenProfits"]) {
                    if (_data["tokenProfits"].hasOwnProperty(key))
                        this.tokenProfits![key] = _data["tokenProfits"][key];
                }
            }
            this.totalWorth = _data["totalWorth"];
            this.totalTradeInvest = _data["totalTradeInvest"];
            this.profit = _data["profit"];
        }
    }

    static fromJS(data: any): AggrInvestmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AggrInvestmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.investments)) {
            data["investments"] = [];
            for (let item of this.investments)
                data["investments"].push(item.toJSON());
        }
        if (this.tokenProfits) {
            data["tokenProfits"] = {};
            for (let key in this.tokenProfits) {
                if (this.tokenProfits.hasOwnProperty(key))
                    data["tokenProfits"][key] = this.tokenProfits[key];
            }
        }
        data["totalWorth"] = this.totalWorth;
        data["totalTradeInvest"] = this.totalTradeInvest;
        data["profit"] = this.profit;
        return data; 
    }
}

export interface IAggrInvestmentDTO {
    investments?: InvestmentDTO[] | undefined;
    tokenProfits?: { [key: string]: number; } | undefined;
    totalWorth?: number;
    totalTradeInvest?: number;
    profit?: number;
}

export enum TransactionType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class CryptoTransaction implements ICryptoTransaction {
    readonly id?: string;
    type?: TransactionType;
    readonly dateTime?: Date;
    readonly inAmount?: number;
    readonly inCurrency?: string | undefined;
    readonly outAmount?: number;
    readonly outCurrency?: string | undefined;
    readonly feeAmount?: number;
    readonly feeCurrency?: string | undefined;
    readonly buyAmount?: number;
    readonly buyCurrency?: string | undefined;
    buyFiatRate?: number;
    buyFiatAmount?: number;
    readonly sellAmount?: number;
    readonly sellCurrency?: string | undefined;
    readonly rate?: number;
    fromAddress?: string | undefined;
    toAddress?: string | undefined;
    readonly exchangeId?: string;
    readonly comment?: string | undefined;
    readonly transactionKey?: string | undefined;
    readonly transactionHash?: string | undefined;

    constructor(data?: ICryptoTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.type = _data["type"];
            (<any>this).dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            (<any>this).inAmount = _data["inAmount"];
            (<any>this).inCurrency = _data["inCurrency"];
            (<any>this).outAmount = _data["outAmount"];
            (<any>this).outCurrency = _data["outCurrency"];
            (<any>this).feeAmount = _data["feeAmount"];
            (<any>this).feeCurrency = _data["feeCurrency"];
            (<any>this).buyAmount = _data["buyAmount"];
            (<any>this).buyCurrency = _data["buyCurrency"];
            this.buyFiatRate = _data["buyFiatRate"];
            this.buyFiatAmount = _data["buyFiatAmount"];
            (<any>this).sellAmount = _data["sellAmount"];
            (<any>this).sellCurrency = _data["sellCurrency"];
            (<any>this).rate = _data["rate"];
            this.fromAddress = _data["fromAddress"];
            this.toAddress = _data["toAddress"];
            (<any>this).exchangeId = _data["exchangeId"];
            (<any>this).comment = _data["comment"];
            (<any>this).transactionKey = _data["transactionKey"];
            (<any>this).transactionHash = _data["transactionHash"];
        }
    }

    static fromJS(data: any): CryptoTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new CryptoTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["inAmount"] = this.inAmount;
        data["inCurrency"] = this.inCurrency;
        data["outAmount"] = this.outAmount;
        data["outCurrency"] = this.outCurrency;
        data["feeAmount"] = this.feeAmount;
        data["feeCurrency"] = this.feeCurrency;
        data["buyAmount"] = this.buyAmount;
        data["buyCurrency"] = this.buyCurrency;
        data["buyFiatRate"] = this.buyFiatRate;
        data["buyFiatAmount"] = this.buyFiatAmount;
        data["sellAmount"] = this.sellAmount;
        data["sellCurrency"] = this.sellCurrency;
        data["rate"] = this.rate;
        data["fromAddress"] = this.fromAddress;
        data["toAddress"] = this.toAddress;
        data["exchangeId"] = this.exchangeId;
        data["comment"] = this.comment;
        data["transactionKey"] = this.transactionKey;
        data["transactionHash"] = this.transactionHash;
        return data; 
    }
}

export interface ICryptoTransaction {
    id?: string;
    type?: TransactionType;
    dateTime?: Date;
    inAmount?: number;
    inCurrency?: string | undefined;
    outAmount?: number;
    outCurrency?: string | undefined;
    feeAmount?: number;
    feeCurrency?: string | undefined;
    buyAmount?: number;
    buyCurrency?: string | undefined;
    buyFiatRate?: number;
    buyFiatAmount?: number;
    sellAmount?: number;
    sellCurrency?: string | undefined;
    rate?: number;
    fromAddress?: string | undefined;
    toAddress?: string | undefined;
    exchangeId?: string;
    comment?: string | undefined;
    transactionKey?: string | undefined;
    transactionHash?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data; 
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}